initSidebarItems({"fn":[["add","Adds `value` to the one currently under `uref` in the global state."],["add_contract_version","Add a new version of a contract to the contract stored at the given `Key`. Note that this contract must have been created by `create_contract` or `create_contract_package_at_hash` first."],["create_contract_package_at_hash","Create a new (versioned) contract stored under a Key::Hash. Initially there are no versions; a version must be added via `add_contract_version` before the contract can be executed."],["create_contract_user_group","Create a new “user group” for a (versioned) contract. User groups associate a set of URefs with a label. Entry points on a contract can be given a list of labels they accept and the runtime will check that a URef from at least one of the allowed groups is present in the caller’s context before execution. This allows access control for entry_points of a contract. This function returns the list of new URefs created for the group (the list will contain `num_new_urefs` elements)."],["dictionary_get","Retrieve `value` stored under `dictionary_item_key` in the dictionary accessed by `dictionary_seed_uref`."],["dictionary_put","Writes `value` under `dictionary_item_key` in the dictionary accessed by `dictionary_seed_uref`."],["disable_contract_version","Disable a version of a contract from the contract stored at the given `Key`. That version of the contract will no longer be callable by `call_versioned_contract`. Note that this contract must have been created by `create_contract` or `create_contract_package_at_hash` first."],["new_contract","Create a new contract stored under a Key::Hash at version 1. You may upgrade this contract in the future; if you want a contract that is locked (i.e. cannot be upgraded) call `new_locked_contract` instead. if `named_keys` are provided, will apply them if `hash_name` is provided, puts contract hash in current context’s named keys under `hash_name` if `uref_name` is provided, puts access_uref in current context’s named keys under `uref_name`"],["new_dictionary","Creates new [`URef`] that represents a seed for a dictionary partition of the global state and puts it under named keys."],["new_locked_contract","Create a locked contract stored under a Key::Hash, which can never be upgraded. This is an irreversible decision; for a contract that can be upgraded use `new_contract` instead. if `named_keys` are provided, will apply them if `hash_name` is provided, puts contract hash in current context’s named keys under `hash_name` if `uref_name` is provided, puts access_uref in current context’s named keys under `uref_name`"],["new_uref","Returns a new unforgeable pointer, where the value is initialized to `init`."],["provision_contract_user_group_uref","Extends specified group with a new `URef`."],["read","Reads value under `uref` in the global state."],["read_or_revert","Reads value under `uref` in the global state, reverts if value not found or is not `T`."],["remove_contract_user_group","Remove a named group from given contract."],["remove_contract_user_group_urefs","Removes specified urefs from a named group."],["write","Writes `value` under `uref` in the global state."]]});